/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: DataModel.proto
 *
 */

import Foundation
import SwiftProtobuf


struct BookInfo: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "BookInfo"}
  public var protoMessageName: String {return "BookInfo"}
  public var protoPackageName: String {return ""}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "id", swift: "id"),
    2: .same(proto: "title", swift: "title"),
    3: .same(proto: "author", swift: "author"),
  ]


  var id: Int64 = 0

  var title: String = ""

  var author: String = ""

  init() {}

  public mutating func _protoc_generated_decodeField(setter: inout SwiftProtobuf.FieldDecoder, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt64.self, value: &id)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &title)
    case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &author)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: inout SwiftProtobuf.Visitor) throws {
    if id != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt64.self, value: id, protoFieldNumber: 1)
    }
    if title != "" {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: title, protoFieldNumber: 2)
    }
    if author != "" {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: author, protoFieldNumber: 3)
    }
  }

  public func _protoc_generated_isEqualTo(other: BookInfo) -> Bool {
    if id != other.id {return false}
    if title != other.title {return false}
    if author != other.author {return false}
    return true
  }
}

struct MyLibrary: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "MyLibrary"}
  public var protoMessageName: String {return "MyLibrary"}
  public var protoPackageName: String {return ""}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "id", swift: "id"),
    2: .same(proto: "name", swift: "name"),
    3: .same(proto: "books", swift: "books"),
    4: .same(proto: "keys", swift: "keys"),
  ]


  var id: Int64 = 0

  var name: String = ""

  var books: [BookInfo] = []

  var keys: Dictionary<String,String> = [:]

  init() {}

  public mutating func _protoc_generated_decodeField(setter: inout SwiftProtobuf.FieldDecoder, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt64.self, value: &id)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &name)
    case 3: try setter.decodeRepeatedMessageField(fieldType: BookInfo.self, value: &books)
    case 4: try setter.decodeMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &keys)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: inout SwiftProtobuf.Visitor) throws {
    if id != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt64.self, value: id, protoFieldNumber: 1)
    }
    if name != "" {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: name, protoFieldNumber: 2)
    }
    if !books.isEmpty {
      try visitor.visitRepeatedMessageField(value: books, protoFieldNumber: 3)
    }
    if !keys.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: keys, protoFieldNumber: 4)
    }
  }

  public func _protoc_generated_isEqualTo(other: MyLibrary) -> Bool {
    if id != other.id {return false}
    if name != other.name {return false}
    if books != other.books {return false}
    if keys != other.keys {return false}
    return true
  }
}
